#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import concurrent.futures.process
import errno
import os
import subprocess
import pandas as pd
from datetime import datetime
import Mapper_python2
from Bam2Reads_function.BAM2Reads import BAM2Reads


# TODO R2 with good adapter
#  TODO ORFget + extend (parametre) ==> CDS ==> periodicite
# detectIGR : pysam, bokeh
# TODO partial codon ?
# install cutadapt by command "pip3 install cutadapt"
# install bowtie by https://github.com/BenLangmead/bowtie then make then "sudo make install"
# install samtools through downloading the current source release of samtools (www.htslib.org/download/)
def get_args():
    """

    :return: parameters
    """
    parser = argparse.ArgumentParser(description='ORFphase')
    parser.add_argument("-gff",
                        type=str,
                        required=True,
                        nargs="+",
                        help="GFF annotation file")
    parser.add_argument("-fasta",
                        type=str,
                        required=True,
                        nargs="+",
                        help="FASTA file containing the genome sequence")
    parser.add_argument("-fastq",
                        type=str,
                        required=True,
                        nargs="+",
                        help="FASTQ file containing the riboseq reads")
    parser.add_argument("-kmer",  # can only choose one option of kmer
                        type=int,
                        required=False,
                        nargs=2,
                        default=[26, 30])
    parser.add_argument("-cutdir",
                        type=str,
                        required=False,  # if directory not given, launch cutadapt
                        nargs="+",
                        help="Directory containing the directories of cutadapt files"
                        )
    parser.add_argument("-adapt",
                        type=str,
                        required=False,  # if not given, will look in list and if not found error message (TODO)
                        nargs="+",
                        help="Nucleotidic sequence of the adaptor for riboseq")
    parser.add_argument("-thr",  # can only choose 1 threshold for all the files
                        type=int,
                        required=False,
                        nargs=1,
                        default=100,
                        help="Minimal number of reads to consider to calculate the mean and median per phase")
    parser.add_argument("-options",
                        type=str,
                        nargs="?",
                        default="IMBP",
                        help='''What needs to be launched:
                            I : indexing of the genome file (Bowtie-build)
                            M : mapping of the reads on the index file to bam files
                            B : counting of the reads by phase and periodicity (Bam2reads function)
                            P : plotting of periodicity and phasing
                            WARNING : I,M and B should be keeped if you never launched Ribomap or the name/path 
                            of the files, may differ from what is generated by Ribomap. 
                        ''')
    args = parser.parse_args()
    return args


try:
    from subprocess import CompletedProcess
except ImportError:
    # Python 2

    class CompletedProcess:

        def __init__(self, args, returncode, stdout=None, stderr=None):
            self.args = args
            self.returncode = returncode
            self.stdout = stdout
            self.stderr = stderr

        def check_returncode(self):
            if self.returncode != 0:
                err = subprocess.CalledProcessError(self.returncode, self.args, output=self.stdout)
                raise err
            return self.returncode


    def sp_run(*popenargs, **kwargs):
        input = kwargs.pop("input", None)
        check = kwargs.pop("handle", False)
        if input is not None:
            if 'stdin' in kwargs:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = subprocess.PIPE
        process = subprocess.Popen(*popenargs, **kwargs)
        try:
            outs, errs = process.communicate(input)
        except:
            process.kill()
            process.wait()
            raise
        returncode = process.poll()
        if check and returncode:
            raise subprocess.CalledProcessError(returncode, popenargs, output=outs)
        return CompletedProcess(popenargs, returncode, stdout=outs, stderr=errs)


    subprocess.run = sp_run
    # ^ This monkey patch allows it work on Python 2 or 3 the same way


# 2. Create gff file of the transcriptome or intergenic ORFs
def read_multiFASTA(fasta_file):
    """
    Create dictionary from fasta_file with the gene name as key and the value being the sequence
    :param fasta_file: fasta file to read
    :return: dictionnary
    """
    dico = {}
    with open(fasta_file, 'r') as fasta:
        for line in fasta:
            if line.startswith('>'):
                name = str(line.split()[0])[1:]
                dico[name] = ''
            elif line == '\n':
                continue
            else:
                seq = line.strip().replace("*", "")
                dico[name] = dico[name] + seq
    return (dico)


def reads_phase_percentage(tab):
    """
    From the reads count table, give the percentage of all phases
    :param tab: reads count table
    :return: list of the percentage of the three phases
    """
    perc = []
    # Sum of phase columns in tab
    phase0sum = tab["Number p0"].sum()
    phase1sum = tab["Number p1"].sum()
    phase2sum = tab["Number p2"].sum()
    sumreads = tab["Number reads"].sum()

    # List with percentage of each phase
    perc.append(phase0sum / sumreads * 100)
    perc.append(phase1sum / sumreads * 100)
    perc.append(phase2sum / sumreads * 100)
    return perc


def phase_decision_mean_median(kmer, riboseq_name, reads_thr):
    with open("{}_phase_median_mean.tab".format(riboseq_name), "w") as median_mean_tab:
        median_mean_tab.write("Riboseq\tSize\tMedian_p0\tMedian_p1\tMedian_p2\tMean_p0\tMean_p1\tMean_p2\n")
        for size in kmer:
            median_by_kmer = []
            tab = pd.read_table("./kmer_{}/{}_kmer_{}_phasing_reads.tab".format(size, riboseq_name, size),
                                sep='\t')
            tab = tab[tab["Number reads"] >= reads_thr]

            # List with median of number of reads per phase
            median_by_kmer.append(tab["Perc. p0"].median())
            median_by_kmer.append(tab["Perc. p1"].median())
            median_by_kmer.append(tab["Perc. p2"].median())
            mean_by_kmer = reads_phase_percentage(tab)
            median_mean_tab.write("{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\n".format(riboseq_name, size, median_by_kmer[0],
                                                                            median_by_kmer[1], median_by_kmer[2],
                                                                            mean_by_kmer[0], mean_by_kmer[1],
                                                                            mean_by_kmer[2]))


def main():
    start_time = datetime.now()

    # Get the parameters
    parameters = get_args()
    Mapper_python2.parameters_verification(parameters)
    kmer = range(parameters.kmer[0], parameters.kmer[1] + 1)
    reads_thr = parameters.thr
    options = list(parameters.options)
    for input_file in range(len(parameters.fastq)):
        if len(parameters.fasta) == 1:
            genome_file = parameters.fasta[0]
        else:
            genome_file = parameters.fasta[input_file]
        genome_name = os.path.basename(genome_file)
        genome_name = os.path.splitext(genome_name)[0]

        riboseq_file = parameters.fastq[input_file]
        riboseq_name = os.path.basename(riboseq_file)
        riboseq_name = os.path.splitext(riboseq_name)[0]
        if len(parameters.gff) == 1:
            gff_file = parameters.gff[0]
        else:
            gff_file = parameters.gff[input_file]

        with open("ORFphase_{}_log.txt".format(riboseq_name), "w") as log:
            # 1. Extraction of the non-translated sequences of CDS:
            genome_CDS = genome_name + "_phasing.nfasta"
            if os.path.exists(genome_CDS):
                print(genome_CDS + " exists, it will be used to extract the transcriptome. If the file doesn't result "
                                   "from orfget, please rename it and launch ORFphase again".format(genome_name))
            else:
                orfget_cmd = "orfget -fna {} -gff {} -features_include CDS -o {}_phasing -type nucl".format(
                    genome_file, gff_file, genome_name)
                process_orfget = subprocess.Popen(orfget_cmd, shell=True, universal_newlines=True)
                # process_orfget = subprocess.run(orfget_cmd, shell=True)

            # 2. Generation of pseudo GFF file of the CDS transcriptome
            transcriptome_gff = genome_name + "_transcriptome.gff"
            if os.path.exists(transcriptome_gff):
                print(
                    transcriptome_gff + " exists, it will be used for aligning the reads, if the file does not result "
                                        "from ORFphase, please rename it and relaunch ORFphase please")
            else:
                transcriptome = read_multiFASTA(fasta_file=genome_CDS)
                with open(transcriptome_gff, "w") as wgff:
                    for size in transcriptome:
                        wgff.write('{:20s}\t{}\t{:20s}\t{:d}\t{:d}\t{}\t{}\t{}\t{}\n'.format(
                            size, 'SGD', 'gene', 1, len(transcriptome[size]), '.', '+', '0', str('ID=' + size)))

            # 3. Potential launch of cutadapt and definition of cutadapt files directory
            if not parameters.cutdir:
                if len(parameters.adapt) == 1:
                    adapt = parameters.adapt[0]
                else:
                    adapt = parameters.adapt[input_file]
                print("\nThe cutadapt process will be launched")
                try:
                    import cutadapt
                    print("\nNo directory for cutadapt files has been given, the cutadapt process is launching. "
                          "The reads are cut in {}-kmers".format(parameters.kmer))
                except ImportError:
                    print('''cutadapt is not installed''')
                # with concurrent.futures.ThreadPoolExecutor(max_workers=None) as executor:
                #     for size in kmer:
                #         executor.submit(Mapper_python2.cut_reads, size, riboseq_file, adapt, riboseq_name)
                for size in kmer:
                    Mapper_python2.cut_reads(size, riboseq_file, adapt, riboseq_name)
            else:
                print("\nYou entered directory(ies) for cutadapt files. No cutadapt process will be launched")
                if len(parameters.cutdir) == 1:
                    cutdir = parameters.cutdir[0]
                else:
                    cutdir = parameters.cutdir[input_file]
                for size in kmer:
                    name_dir = "{}/kmer_{}".format(cutdir, size)
                    if not os.path.isdir(name_dir):
                        print("The directories need to be named as kmer_x with x the size of the kmer.")
                        exit()

            # 4.Mapping of the reads on the non-translated sequences

            # a. Building of the index
            print("We start the mapping")
            if "I" in options:
                cmd_bowtie = 'bowtie-build {}_phasing.nfasta {}_phasing'.format(genome_name, genome_name)
                print("Command launched: ", cmd_bowtie)
                # process_bowtie = subprocess.run(cmd_bowtie, shell=True)
                process_bowtie = subprocess.Popen(cmd_bowtie, shell=True, universal_newlines=True,
                                                  stdout=subprocess.PIPE)

            else:
                print("The basename of Bowtie index files are expected to be : {}_phasing".format(genome_name))

            # b->g. Create count table
            if "M" in options:
                try:
                    import pysam
                    import bokeh
                except ImportError:
                    print("You need to install the python packages pysam and bokeh")
                for size in kmer:
                    Mapper_python2.map2bam(cutdir, size, genome_name, riboseq_name, "phasing")
            else:
                print("The name and path of the bam files are expected to be :"
                      "./kmer_n/{}_kmer_n_sorted_mapped.bam with n the size of the reads".format(riboseq_name))

            if "B" in options:
                print("Counting tables are generated")
                log.write(BAM2Reads(riboseq_name, transcriptome_gff, kmer, "phasing"))
            else:
                print("The name and path of the counting file is expected to be :"
                      "./kmer_n/{}_kmer_n_phasing_reads.tab with n the size of the reads".format(riboseq_name))
            # with concurrent.futures.process.ProcessPoolExecutor(max_workers=None) as executor:
            #     executor.map(map_in_bam_and_count, kmer, [gname] * len(kmer), [rname] * len(kmer), [cutdir] * len(kmer),
            #     [parameters.type]*len(kmer),[gff_to_compare]*len(kmer))
            # 5. Plotting and finding best read size to have a percentage of phase 0 superior to the threshold
            if "P" in options:
                print("The plots of phasing and periodicity are generated")
                for size in kmer:
                    tab = pd.read_table("./kmer_{}/{}_kmer_{}_phasing_reads.tab".format(size, riboseq_name, size),
                                        sep='\t')
                    # Plot of the reads phase and periodicity
                    Mapper_python2.reads_phase_plot(tab, size, riboseq_name,
                                            reads_thr,
                                            "phasing")
                    Mapper_python2.reads_periodicity(size, riboseq_name, "phasing", "start")
                    Mapper_python2.reads_periodicity(size, riboseq_name, "phasing", "stop")
            phase_decision_mean_median(kmer, riboseq_name, reads_thr)
    end_time = datetime.now()
    print("\n\n")
    print('Duration: {}'.format(end_time - start_time))


main()
